{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Data Structures and Algorithms \u00b6 Overview \u00b6 GraphX: https://github.com/cggos/GraphX \u590d\u6742\u5ea6\u5206\u6790 \u00b6 \u65f6\u95f4\u590d\u6742\u5ea6 \u7a7a\u95f4\u590d\u6742\u5ea6 Data Structures \u00b6 \u7ebf\u6027\u8868 \u6570\u7ec4\uff1a\u5b57\u7b26\u4e32 \u77e9\u9635 \u94fe\u8868 \u6811 \u56fe \u6808\u548c\u961f\u5217 Tutorial \u00b6 Books \u00b6 Algorithm Design The Algorithm Design Manual Algorithms Open Data Structures Algorithms and data structures in C/C++ cggos/DSA-CPP Code \u00b6 Algo_Ds \u6570\u636e\u7ed3\u6784(C/C++) \u6570\u636e\u7ed3\u6784(Java) Introduction to Algorithms cggos/sword_point_to_offer : \u300a\u5251\u6307Offer\uff1a\u540d\u4f01\u9762\u8bd5\u5b98\u7cbe\u8bb2\u5178\u578b\u7f16\u7a0b\u9898(\u7eaa\u5ff5\u7248)\u300b","title":"Home"},{"location":"#Data_Structures_and_Algorithms","text":"","title":"Data Structures and Algorithms"},{"location":"#Overview","text":"GraphX: https://github.com/cggos/GraphX","title":"Overview"},{"location":"#\u590d\u6742\u5ea6\u5206\u6790","text":"\u65f6\u95f4\u590d\u6742\u5ea6 \u7a7a\u95f4\u590d\u6742\u5ea6","title":"\u590d\u6742\u5ea6\u5206\u6790"},{"location":"#Data_Structures","text":"\u7ebf\u6027\u8868 \u6570\u7ec4\uff1a\u5b57\u7b26\u4e32 \u77e9\u9635 \u94fe\u8868 \u6811 \u56fe \u6808\u548c\u961f\u5217","title":"Data Structures"},{"location":"#Tutorial","text":"","title":"Tutorial"},{"location":"#Books","text":"Algorithm Design The Algorithm Design Manual Algorithms Open Data Structures Algorithms and data structures in C/C++ cggos/DSA-CPP","title":"Books"},{"location":"#Code","text":"Algo_Ds \u6570\u636e\u7ed3\u6784(C/C++) \u6570\u636e\u7ed3\u6784(Java) Introduction to Algorithms cggos/sword_point_to_offer : \u300a\u5251\u6307Offer\uff1a\u540d\u4f01\u9762\u8bd5\u5b98\u7cbe\u8bb2\u5178\u578b\u7f16\u7a0b\u9898(\u7eaa\u5ff5\u7248)\u300b","title":"Code"},{"location":"alg/","text":"Algorithms \u00b6 \u9012\u5f52\u548c\u5faa\u73af \u67e5\u627e\u548c\u6392\u5e8f \u6392\u5217\u7ec4\u5408\u7b97\u6cd5 \u56de\u6eaf\u6cd5 \u52a8\u6001\u89c4\u5212\u4e0e\u8d2a\u5a6a\u7b97\u6cd5 \u4f4d\u8fd0\u7b97","title":"Overview"},{"location":"alg/#Algorithms","text":"\u9012\u5f52\u548c\u5faa\u73af \u67e5\u627e\u548c\u6392\u5e8f \u6392\u5217\u7ec4\u5408\u7b97\u6cd5 \u56de\u6eaf\u6cd5 \u52a8\u6001\u89c4\u5212\u4e0e\u8d2a\u5a6a\u7b97\u6cd5 \u4f4d\u8fd0\u7b97","title":"Algorithms"},{"location":"alg/dp/","text":"DP (Dynamic Programming) \u00b6","title":"Dynamic Programming"},{"location":"alg/dp/#DP_Dynamic_Programming","text":"","title":"DP (Dynamic Programming)"},{"location":"alg/search/","text":"Search \u00b6 Binary Search \u00b6 \u4e8c\u5206\u67e5\u627e\u4e5f\u79f0\u6298\u534a\u67e5\u627e\uff08Binary Search\uff09\uff0c\u5b83\u662f\u4e00\u79cd\u6548\u7387\u8f83\u9ad8\u7684\u67e5\u627e\u65b9\u6cd5\uff0c\u53ef\u4ee5\u5728\u6570\u636e\u89c4\u6a21\u7684\u5bf9\u6570\u65f6\u95f4\u590d\u6742\u5ea6\u5185\u5b8c\u6210\u67e5\u627e\u3002 \u4e8c\u5206\u67e5\u627e\u53ef\u4ee5\u5e94\u7528\u4e8e\u6570\u7ec4\uff0c\u662f\u56e0\u4e3a\u6570\u7ec4\u5177\u6709\u6709\u968f\u673a\u8bbf\u95ee\u7684\u7279\u70b9\uff0c\u5e76\u4e14\u6570\u7ec4\u662f\u6709\u5e8f\u7684\u3002 \u4e8c\u5206\u67e5\u627e\u4f53\u73b0\u7684\u6570\u5b66\u601d\u60f3\u662f\u300c\u51cf\u800c\u6cbb\u4e4b\u300d\uff0c\u53ef\u4ee5\u901a\u8fc7\u5f53\u524d\u770b\u5230\u7684\u4e2d\u95f4\u5143\u7d20\u7684\u7279\u70b9\u63a8\u6d4b\u5b83\u4e24\u4fa7\u5143\u7d20\u7684\u6027\u8d28\uff0c\u4ee5\u8fbe\u5230\u7f29\u51cf\u95ee\u9898\u89c4\u6a21\u7684\u6548\u679c\u3002 LeetCode \u00b6 Binary Search Code: https://leetcode.cn/tag/binary-search/ leetcode 69: x \u7684\u5e73\u65b9\u6839","title":"Search"},{"location":"alg/search/#Search","text":"","title":"Search"},{"location":"alg/search/#Binary_Search","text":"\u4e8c\u5206\u67e5\u627e\u4e5f\u79f0\u6298\u534a\u67e5\u627e\uff08Binary Search\uff09\uff0c\u5b83\u662f\u4e00\u79cd\u6548\u7387\u8f83\u9ad8\u7684\u67e5\u627e\u65b9\u6cd5\uff0c\u53ef\u4ee5\u5728\u6570\u636e\u89c4\u6a21\u7684\u5bf9\u6570\u65f6\u95f4\u590d\u6742\u5ea6\u5185\u5b8c\u6210\u67e5\u627e\u3002 \u4e8c\u5206\u67e5\u627e\u53ef\u4ee5\u5e94\u7528\u4e8e\u6570\u7ec4\uff0c\u662f\u56e0\u4e3a\u6570\u7ec4\u5177\u6709\u6709\u968f\u673a\u8bbf\u95ee\u7684\u7279\u70b9\uff0c\u5e76\u4e14\u6570\u7ec4\u662f\u6709\u5e8f\u7684\u3002 \u4e8c\u5206\u67e5\u627e\u4f53\u73b0\u7684\u6570\u5b66\u601d\u60f3\u662f\u300c\u51cf\u800c\u6cbb\u4e4b\u300d\uff0c\u53ef\u4ee5\u901a\u8fc7\u5f53\u524d\u770b\u5230\u7684\u4e2d\u95f4\u5143\u7d20\u7684\u7279\u70b9\u63a8\u6d4b\u5b83\u4e24\u4fa7\u5143\u7d20\u7684\u6027\u8d28\uff0c\u4ee5\u8fbe\u5230\u7f29\u51cf\u95ee\u9898\u89c4\u6a21\u7684\u6548\u679c\u3002","title":"Binary Search"},{"location":"alg/search/#LeetCode","text":"Binary Search Code: https://leetcode.cn/tag/binary-search/ leetcode 69: x \u7684\u5e73\u65b9\u6839","title":"LeetCode"},{"location":"alg/sort/","text":"Sort \u00b6 Overview \u00b6 \u5341\u5927\u6392\u5e8f\u4ece\u5165\u95e8\u5230\u5165\u8d58 (LeetCode)","title":"Sort"},{"location":"alg/sort/#Sort","text":"","title":"Sort"},{"location":"alg/sort/#Overview","text":"\u5341\u5927\u6392\u5e8f\u4ece\u5165\u95e8\u5230\u5165\u8d58 (LeetCode)","title":"Overview"},{"location":"alg/traversal/","text":"Traversal \u00b6 DFS (Depth-First Search) \u00b6 complement: recursion Graph \u00b6 Binary Tree \u00b6 Preorder Traversal Inorder Traversal \u4e8c\u53c9\u641c\u7d22\u6811\u7684\u4e2d\u5e8f\u904d\u5386\u4e3a \u9012\u589e\u5e8f\u5217 Postorder Traversal C++ vector < int > * res ; void dfs ( TreeNode * node ) { if ( node -> left != nullptr ) dfs ( node -> left ); if ( node -> right != nullptr ) dfs ( node -> right ); res -> push_back ( node -> val ); } vector < int > preorderTraversal ( TreeNode * root ) { res = new vector < int > (); if ( root != nullptr ) dfs ( root ); return * res ; } BFS (Breadth-First Search) \u00b6 complement: iteration / circulation Binary Tree \u00b6 Level-order Traversal C++ vector < vector < int >> levelOrder ( TreeNode * root ) { vector < vector < int >> ret ; if ( root == nullptr ) return ret ; queue < TreeNode *> q ; q . push ( root ); while ( ! q . empty ()) { int sz = q . size (); ret . push_back ( vector < int > ()); for ( int i = 0 ; i < sz ; i ++ ) { auto node = q . front (); q . pop (); ret . back (). push_back ( node -> val ); if ( node -> left != nullptr ) q . push ( node -> left ); if ( node -> right != nullptr ) q . push ( node -> right ); } } return ret ; } BFS (Best-First Search) \u00b6 Dijkstra Algorithm LeetCode \u00b6 leetcode 200: \u5c9b\u5c7f\u6570\u91cf C++ int nr = 0 ; int nc = 0 ; const int dx [ 4 ] = { 0 , 0 , -1 , 1 }; const int dy [ 4 ] = { -1 , 1 , 0 , 0 }; void dfs ( vector < vector < char >>& grid , int r , int c ) { grid [ r ][ c ] = '0' ; if ( r -1 >= 0 && grid [ r -1 ][ c ] == '1' ) dfs ( grid , r -1 , c ); if ( r + 1 < nr && grid [ r + 1 ][ c ] == '1' ) dfs ( grid , r + 1 , c ); if ( c -1 >= 0 && grid [ r ][ c -1 ] == '1' ) dfs ( grid , r , c -1 ); if ( c + 1 < nc && grid [ r ][ c + 1 ] == '1' ) dfs ( grid , r , c + 1 ); } void bfs ( vector < vector < char >>& grid , int r , int c ) { queue < std :: pair < int , int >> que ; que . push ({ r , c }); grid [ r ][ c ] = '0' ; while ( ! que . empty ()) { auto rc = que . front (); que . pop (); for ( int i = 0 ; i < 4 ; i ++ ) { int y = rc . first + dy [ i ]; int x = rc . second + dx [ i ]; if ( x >= 0 && x < nc && y >= 0 && y < nr && grid [ y ][ x ] == '1' ) { que . push ({ y , x }); grid [ y ][ x ] = '0' ; } } } } int numIslands ( vector < vector < char >>& grid ) { nr = grid . size (); if ( nr == 0 ) return nr ; nc = grid [ 0 ]. size (); int num = 0 ; for ( int y = 0 ; y < nr ; y ++ ) { for ( int x = 0 ; x < nc ; x ++ ) { if ( grid [ y ][ x ] == '1' ) { num ++ ; bfs ( grid , y , x ); } } } return num ; }","title":"Traversal"},{"location":"alg/traversal/#Traversal","text":"","title":"Traversal"},{"location":"alg/traversal/#DFS_Depth-First_Search","text":"complement: recursion","title":"DFS (Depth-First Search)"},{"location":"alg/traversal/#Graph","text":"","title":"Graph"},{"location":"alg/traversal/#Binary_Tree","text":"Preorder Traversal Inorder Traversal \u4e8c\u53c9\u641c\u7d22\u6811\u7684\u4e2d\u5e8f\u904d\u5386\u4e3a \u9012\u589e\u5e8f\u5217 Postorder Traversal C++ vector < int > * res ; void dfs ( TreeNode * node ) { if ( node -> left != nullptr ) dfs ( node -> left ); if ( node -> right != nullptr ) dfs ( node -> right ); res -> push_back ( node -> val ); } vector < int > preorderTraversal ( TreeNode * root ) { res = new vector < int > (); if ( root != nullptr ) dfs ( root ); return * res ; }","title":"Binary Tree"},{"location":"alg/traversal/#BFS_Breadth-First_Search","text":"complement: iteration / circulation","title":"BFS (Breadth-First Search)"},{"location":"alg/traversal/#Binary_Tree_1","text":"Level-order Traversal C++ vector < vector < int >> levelOrder ( TreeNode * root ) { vector < vector < int >> ret ; if ( root == nullptr ) return ret ; queue < TreeNode *> q ; q . push ( root ); while ( ! q . empty ()) { int sz = q . size (); ret . push_back ( vector < int > ()); for ( int i = 0 ; i < sz ; i ++ ) { auto node = q . front (); q . pop (); ret . back (). push_back ( node -> val ); if ( node -> left != nullptr ) q . push ( node -> left ); if ( node -> right != nullptr ) q . push ( node -> right ); } } return ret ; }","title":"Binary Tree"},{"location":"alg/traversal/#BFS_Best-First_Search","text":"Dijkstra Algorithm","title":"BFS (Best-First Search)"},{"location":"alg/traversal/#LeetCode","text":"leetcode 200: \u5c9b\u5c7f\u6570\u91cf C++ int nr = 0 ; int nc = 0 ; const int dx [ 4 ] = { 0 , 0 , -1 , 1 }; const int dy [ 4 ] = { -1 , 1 , 0 , 0 }; void dfs ( vector < vector < char >>& grid , int r , int c ) { grid [ r ][ c ] = '0' ; if ( r -1 >= 0 && grid [ r -1 ][ c ] == '1' ) dfs ( grid , r -1 , c ); if ( r + 1 < nr && grid [ r + 1 ][ c ] == '1' ) dfs ( grid , r + 1 , c ); if ( c -1 >= 0 && grid [ r ][ c -1 ] == '1' ) dfs ( grid , r , c -1 ); if ( c + 1 < nc && grid [ r ][ c + 1 ] == '1' ) dfs ( grid , r , c + 1 ); } void bfs ( vector < vector < char >>& grid , int r , int c ) { queue < std :: pair < int , int >> que ; que . push ({ r , c }); grid [ r ][ c ] = '0' ; while ( ! que . empty ()) { auto rc = que . front (); que . pop (); for ( int i = 0 ; i < 4 ; i ++ ) { int y = rc . first + dy [ i ]; int x = rc . second + dx [ i ]; if ( x >= 0 && x < nc && y >= 0 && y < nr && grid [ y ][ x ] == '1' ) { que . push ({ y , x }); grid [ y ][ x ] = '0' ; } } } } int numIslands ( vector < vector < char >>& grid ) { nr = grid . size (); if ( nr == 0 ) return nr ; nc = grid [ 0 ]. size (); int num = 0 ; for ( int y = 0 ; y < nr ; y ++ ) { for ( int x = 0 ; x < nc ; x ++ ) { if ( grid [ y ][ x ] == '1' ) { num ++ ; bfs ( grid , y , x ); } } } return num ; }","title":"LeetCode"},{"location":"cpp/","text":"C++ \u00b6 Overview \u00b6 C++ \u7b14\u8bb0\uff1a https://cgabc.xyz/posts/2da2039a/ \u65e0\u9501\u7f16\u7a0b \u00b6 \u5143\u7f16\u7a0b \u00b6 Zero Overhead \u00b6","title":"Overview"},{"location":"cpp/#C","text":"","title":"C++"},{"location":"cpp/#Overview","text":"C++ \u7b14\u8bb0\uff1a https://cgabc.xyz/posts/2da2039a/","title":"Overview"},{"location":"cpp/#\u65e0\u9501\u7f16\u7a0b","text":"","title":"\u65e0\u9501\u7f16\u7a0b"},{"location":"cpp/#\u5143\u7f16\u7a0b","text":"","title":"\u5143\u7f16\u7a0b"},{"location":"cpp/#Zero_Overhead","text":"","title":"Zero Overhead"},{"location":"cpp/lib/","text":"C++ Libs \u00b6 Time Utils \u00b6 Configure file \u00b6 libConfig++ is a portable and flexible C++ library for reading configuration files which were written in C style syntax JsonCpp libyaml-cpp rosparam cv::FileStorage Log Utils \u00b6","title":"Libs"},{"location":"cpp/lib/#C_Libs","text":"","title":"C++ Libs"},{"location":"cpp/lib/#Time_Utils","text":"","title":"Time Utils"},{"location":"cpp/lib/#Configure_file","text":"libConfig++ is a portable and flexible C++ library for reading configuration files which were written in C style syntax JsonCpp libyaml-cpp rosparam cv::FileStorage","title":"Configure file"},{"location":"cpp/lib/#Log_Utils","text":"","title":"Log Utils"},{"location":"tree/","text":"Tree \u00b6 \u4e8c\u53c9\u6811 \u00b6 \u904d\u5386 \u524d\u5e8f\u904d\u5386 \u4e2d\u5e8f\u904d\u5386 \u540e\u5e8f\u904d\u5386 \u5c42\u5e8f\u904d\u5386 \u4e8c\u53c9\u6811\u7684\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316 LeetCode \u00b6 leetcode 236: \u4e8c\u53c9\u6811\u4e24\u7ed3\u70b9\u7684\u6700\u8fd1\u5171\u540c\u7956\u5148\u7ed3\u70b9","title":"Overview"},{"location":"tree/#Tree","text":"","title":"Tree"},{"location":"tree/#\u4e8c\u53c9\u6811","text":"\u904d\u5386 \u524d\u5e8f\u904d\u5386 \u4e2d\u5e8f\u904d\u5386 \u540e\u5e8f\u904d\u5386 \u5c42\u5e8f\u904d\u5386 \u4e8c\u53c9\u6811\u7684\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316","title":"\u4e8c\u53c9\u6811"},{"location":"tree/#LeetCode","text":"leetcode 236: \u4e8c\u53c9\u6811\u4e24\u7ed3\u70b9\u7684\u6700\u8fd1\u5171\u540c\u7956\u5148\u7ed3\u70b9","title":"LeetCode"}]}